/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

const HttpBackend = require("./http-backend");
const AxiosHttpOptions = require("./axios-http-options");
const typedefs = require("../typedefs");

const PRIVATE = Symbol("PRIVATE");

/**
 * Reprents a backend that uses axios as the HTTP library for performing HTTP
 * communications.
 */
class AxiosBackend extends HttpBackend {
  /**
   * Constructs a new instance of the axios backend, based on an instance of
   * the axios library itself.
   *
   * @param {typedefs.ClientOptions} options Options for controlling how the backend behaves.
   * @param {*} axiosInstance Axios instance on which to base the backend.
   */
  constructor(options, axiosInstance) {
    super(options);
    this[PRIVATE] = {
      axios: axiosInstance,
    };
  }

  registerInterceptors(interceptor) {
    const { axios } = this[PRIVATE];
    axios.interceptors.request.use(
      (config) => interceptor.interceptRequest(this, config),
      (error) =>
        interceptor.interceptRequestError(this, this.getErrorConfig(error))
    );
    axios.interceptors.response.use(
      (response) =>
        interceptor.interceptResponse(
          this,
          this.getResponseConfig(response),
          response
        ),
      (error) =>
        interceptor.interceptResponseError(
          this,
          this.getErrorConfig(error),
          error
        )
    );
    return axios;
  }

  /**
   * Retrieves the axios configuration from an error generated by axios.
   *
   * @param {*} error Error whose config will be retried.
   * @returns {*} Configuration of the error.
   */
  getErrorConfig(error) {
    const { config } = error;

    if (!config) {
      throw new Error("Axios error does not have a config");
    }

    return config;
  }

  /**
   * Retrieves the axios configuration from a response generated by axios.
   *
   * @param {*} response Response whose config will be retried.
   * @returns {*} Configuration of the response.
   */
  getResponseConfig(response) {
    const { config } = response;

    if (!config) {
      throw new Error("Axios response does not have a config");
    }

    return config;
  }

  async getRequestConfig(options) {
    const requestOptions = await super.getRequestConfig(options);

    let { timeout } = requestOptions;

    // only add a timeout if one wasn't already specified by the
    // consumer
    if (!timeout) {
      timeout = options.getTimeout();
    }

    return {
      ...requestOptions,
      timeout,
    };
  }

  submitRequest(options) {
    const { axios } = this[PRIVATE];
    return axios(options);
  }

  getErrorResponse(httpOptions, error) {
    const { isAxiosError = false, status, response } = error;
    if (isAxiosError) {
      httpOptions.logWarn(
        `request failed with axios error status code ${status}`
      );
    } else {
      httpOptions.logWarn("request failed with unknown error type", error);
    }
    return response;
  }

  getSetCookies(response) {
    const { headers = {} } = response;
    const headerSetCookie = headers["set-cookie"];
    if (headerSetCookie) {
      return headerSetCookie;
    }
    return [];
  }

  createHttpOptions(options) {
    return new AxiosHttpOptions(options, this.getClientOptions());
  }
}

module.exports = AxiosBackend;
